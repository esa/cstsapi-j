/**
 * This class file was automatically generated by jASN1 v1.11.3-SNAPSHOT (http://www.beanit.com)
 */

package frm.csts.functional.resource.types;

import java.io.IOException;
import java.io.EOFException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.io.Serializable;
import com.beanit.jasn1.ber.*;
import com.beanit.jasn1.ber.types.*;
import com.beanit.jasn1.ber.types.string.*;


public class FrameDataSinkStorageSelection implements BerType, Serializable {

	private static final long serialVersionUID = 1L;

	public byte[] code = null;
	public static class ChannelList implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public byte[] code = null;
		public static class TM implements BerType, Serializable {

			private static final long serialVersionUID = 1L;

			public static class SEQUENCE implements BerType, Serializable {

				private static final long serialVersionUID = 1L;

				public static class TmVcSelection implements BerType, Serializable {

					private static final long serialVersionUID = 1L;

					public byte[] code = null;
					public static class SelectedTmVcids implements BerType, Serializable {

						private static final long serialVersionUID = 1L;

						public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);
						public byte[] code = null;
						private List<BerInteger> seqOf = null;

						public SelectedTmVcids() {
							seqOf = new ArrayList<BerInteger>();
						}

						public SelectedTmVcids(byte[] code) {
							this.code = code;
						}

						public List<BerInteger> getBerInteger() {
							if (seqOf == null) {
								seqOf = new ArrayList<BerInteger>();
							}
							return seqOf;
						}

						public int encode(OutputStream reverseOS) throws IOException {
							return encode(reverseOS, true);
						}

						public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

							if (code != null) {
								for (int i = code.length - 1; i >= 0; i--) {
									reverseOS.write(code[i]);
								}
								if (withTag) {
									return tag.encode(reverseOS) + code.length;
								}
								return code.length;
							}

							int codeLength = 0;
							for (int i = (seqOf.size() - 1); i >= 0; i--) {
								codeLength += seqOf.get(i).encode(reverseOS, true);
							}

							codeLength += BerLength.encodeLength(reverseOS, codeLength);

							if (withTag) {
								codeLength += tag.encode(reverseOS);
							}

							return codeLength;
						}

						public int decode(InputStream is) throws IOException {
							return decode(is, true);
						}

						public int decode(InputStream is, boolean withTag) throws IOException {
							int codeLength = 0;
							int subCodeLength = 0;
							if (withTag) {
								codeLength += tag.decodeAndCheck(is);
							}

							BerLength length = new BerLength();
							codeLength += length.decode(is);
							int totalLength = length.val;

							while (subCodeLength < totalLength) {
								BerInteger element = new BerInteger();
								subCodeLength += element.decode(is, true);
								seqOf.add(element);
							}
							if (subCodeLength != totalLength) {
								throw new IOException("Decoded SequenceOf or SetOf has wrong length. Expected " + totalLength + " but has " + subCodeLength);

							}
							codeLength += subCodeLength;

							return codeLength;
						}

						public void encodeAndSave(int encodingSizeGuess) throws IOException {
							ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
							encode(reverseOS, false);
							code = reverseOS.getArray();
						}

						public String toString() {
							StringBuilder sb = new StringBuilder();
							appendAsString(sb, 0);
							return sb.toString();
						}

						public void appendAsString(StringBuilder sb, int indentLevel) {

							sb.append("{\n");
							for (int i = 0; i < indentLevel + 1; i++) {
								sb.append("\t");
							}
							if (seqOf == null) {
								sb.append("null");
							}
							else {
								Iterator<BerInteger> it = seqOf.iterator();
								if (it.hasNext()) {
									sb.append(it.next());
									while (it.hasNext()) {
										sb.append(",\n");
										for (int i = 0; i < indentLevel + 1; i++) {
											sb.append("\t");
										}
										sb.append(it.next());
									}
								}
							}

							sb.append("\n");
							for (int i = 0; i < indentLevel; i++) {
								sb.append("\t");
							}
							sb.append("}");
						}

					}

					private BerNull allTmVcids = null;
					private SelectedTmVcids selectedTmVcids = null;
					
					public TmVcSelection() {
					}

					public TmVcSelection(byte[] code) {
						this.code = code;
					}

					public void setAllTmVcids(BerNull allTmVcids) {
						this.allTmVcids = allTmVcids;
					}

					public BerNull getAllTmVcids() {
						return allTmVcids;
					}

					public void setSelectedTmVcids(SelectedTmVcids selectedTmVcids) {
						this.selectedTmVcids = selectedTmVcids;
					}

					public SelectedTmVcids getSelectedTmVcids() {
						return selectedTmVcids;
					}

					public int encode(OutputStream reverseOS) throws IOException {

						if (code != null) {
							for (int i = code.length - 1; i >= 0; i--) {
								reverseOS.write(code[i]);
							}
							return code.length;
						}

						int codeLength = 0;
						if (selectedTmVcids != null) {
							codeLength += selectedTmVcids.encode(reverseOS, false);
							// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
							reverseOS.write(0xA1);
							codeLength += 1;
							return codeLength;
						}
						
						if (allTmVcids != null) {
							codeLength += allTmVcids.encode(reverseOS, false);
							// write tag: CONTEXT_CLASS, PRIMITIVE, 0
							reverseOS.write(0x80);
							codeLength += 1;
							return codeLength;
						}
						
						throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
					}

					public int decode(InputStream is) throws IOException {
						return decode(is, null);
					}

					public int decode(InputStream is, BerTag berTag) throws IOException {

						int codeLength = 0;
						BerTag passedTag = berTag;

						if (berTag == null) {
							berTag = new BerTag();
							codeLength += berTag.decode(is);
						}

						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
							allTmVcids = new BerNull();
							codeLength += allTmVcids.decode(is, false);
							return codeLength;
						}

						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
							selectedTmVcids = new SelectedTmVcids();
							codeLength += selectedTmVcids.decode(is, false);
							return codeLength;
						}

						if (passedTag != null) {
							return 0;
						}

						throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
					}

					public void encodeAndSave(int encodingSizeGuess) throws IOException {
						ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
						encode(reverseOS);
						code = reverseOS.getArray();
					}

					public String toString() {
						StringBuilder sb = new StringBuilder();
						appendAsString(sb, 0);
						return sb.toString();
					}

					public void appendAsString(StringBuilder sb, int indentLevel) {

						if (allTmVcids != null) {
							sb.append("allTmVcids: ").append(allTmVcids);
							return;
						}

						if (selectedTmVcids != null) {
							sb.append("selectedTmVcids: ");
							selectedTmVcids.appendAsString(sb, indentLevel + 1);
							return;
						}

						sb.append("<none>");
					}

				}

				public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

				public byte[] code = null;
				private BerInteger tmScid = null;
				private TmVcSelection tmVcSelection = null;
				
				public SEQUENCE() {
				}

				public SEQUENCE(byte[] code) {
					this.code = code;
				}

				public void setTmScid(BerInteger tmScid) {
					this.tmScid = tmScid;
				}

				public BerInteger getTmScid() {
					return tmScid;
				}

				public void setTmVcSelection(TmVcSelection tmVcSelection) {
					this.tmVcSelection = tmVcSelection;
				}

				public TmVcSelection getTmVcSelection() {
					return tmVcSelection;
				}

				public int encode(OutputStream reverseOS) throws IOException {
					return encode(reverseOS, true);
				}

				public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

					if (code != null) {
						for (int i = code.length - 1; i >= 0; i--) {
							reverseOS.write(code[i]);
						}
						if (withTag) {
							return tag.encode(reverseOS) + code.length;
						}
						return code.length;
					}

					int codeLength = 0;
					codeLength += tmVcSelection.encode(reverseOS);
					
					codeLength += tmScid.encode(reverseOS, true);
					
					codeLength += BerLength.encodeLength(reverseOS, codeLength);

					if (withTag) {
						codeLength += tag.encode(reverseOS);
					}

					return codeLength;

				}

				public int decode(InputStream is) throws IOException {
					return decode(is, true);
				}

				public int decode(InputStream is, boolean withTag) throws IOException {
					int codeLength = 0;
					int subCodeLength = 0;
					BerTag berTag = new BerTag();

					if (withTag) {
						codeLength += tag.decodeAndCheck(is);
					}

					BerLength length = new BerLength();
					codeLength += length.decode(is);

					int totalLength = length.val;
					codeLength += totalLength;

					subCodeLength += berTag.decode(is);
					if (berTag.equals(BerInteger.tag)) {
						tmScid = new BerInteger();
						subCodeLength += tmScid.decode(is, false);
						subCodeLength += berTag.decode(is);
					}
					else {
						throw new IOException("Tag does not match the mandatory sequence element tag.");
					}
					
					tmVcSelection = new TmVcSelection();
					subCodeLength += tmVcSelection.decode(is, berTag);
					if (subCodeLength == totalLength) {
						return codeLength;
					}
					throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

					
				}

				public void encodeAndSave(int encodingSizeGuess) throws IOException {
					ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
					encode(reverseOS, false);
					code = reverseOS.getArray();
				}

				public String toString() {
					StringBuilder sb = new StringBuilder();
					appendAsString(sb, 0);
					return sb.toString();
				}

				public void appendAsString(StringBuilder sb, int indentLevel) {

					sb.append("{");
					sb.append("\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (tmScid != null) {
						sb.append("tmScid: ").append(tmScid);
					}
					else {
						sb.append("tmScid: <empty-required-field>");
					}
					
					sb.append(",\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (tmVcSelection != null) {
						sb.append("tmVcSelection: ");
						tmVcSelection.appendAsString(sb, indentLevel + 1);
					}
					else {
						sb.append("tmVcSelection: <empty-required-field>");
					}
					
					sb.append("\n");
					for (int i = 0; i < indentLevel; i++) {
						sb.append("\t");
					}
					sb.append("}");
				}

			}

			public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);
			public byte[] code = null;
			private List<SEQUENCE> seqOf = null;

			public TM() {
				seqOf = new ArrayList<SEQUENCE>();
			}

			public TM(byte[] code) {
				this.code = code;
			}

			public List<SEQUENCE> getSEQUENCE() {
				if (seqOf == null) {
					seqOf = new ArrayList<SEQUENCE>();
				}
				return seqOf;
			}

			public int encode(OutputStream reverseOS) throws IOException {
				return encode(reverseOS, true);
			}

			public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

				if (code != null) {
					for (int i = code.length - 1; i >= 0; i--) {
						reverseOS.write(code[i]);
					}
					if (withTag) {
						return tag.encode(reverseOS) + code.length;
					}
					return code.length;
				}

				int codeLength = 0;
				for (int i = (seqOf.size() - 1); i >= 0; i--) {
					codeLength += seqOf.get(i).encode(reverseOS, true);
				}

				codeLength += BerLength.encodeLength(reverseOS, codeLength);

				if (withTag) {
					codeLength += tag.encode(reverseOS);
				}

				return codeLength;
			}

			public int decode(InputStream is) throws IOException {
				return decode(is, true);
			}

			public int decode(InputStream is, boolean withTag) throws IOException {
				int codeLength = 0;
				int subCodeLength = 0;
				if (withTag) {
					codeLength += tag.decodeAndCheck(is);
				}

				BerLength length = new BerLength();
				codeLength += length.decode(is);
				int totalLength = length.val;

				while (subCodeLength < totalLength) {
					SEQUENCE element = new SEQUENCE();
					subCodeLength += element.decode(is, true);
					seqOf.add(element);
				}
				if (subCodeLength != totalLength) {
					throw new IOException("Decoded SequenceOf or SetOf has wrong length. Expected " + totalLength + " but has " + subCodeLength);

				}
				codeLength += subCodeLength;

				return codeLength;
			}

			public void encodeAndSave(int encodingSizeGuess) throws IOException {
				ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
				encode(reverseOS, false);
				code = reverseOS.getArray();
			}

			public String toString() {
				StringBuilder sb = new StringBuilder();
				appendAsString(sb, 0);
				return sb.toString();
			}

			public void appendAsString(StringBuilder sb, int indentLevel) {

				sb.append("{\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				if (seqOf == null) {
					sb.append("null");
				}
				else {
					Iterator<SEQUENCE> it = seqOf.iterator();
					if (it.hasNext()) {
						it.next().appendAsString(sb, indentLevel + 1);
						while (it.hasNext()) {
							sb.append(",\n");
							for (int i = 0; i < indentLevel + 1; i++) {
								sb.append("\t");
							}
							it.next().appendAsString(sb, indentLevel + 1);
						}
					}
				}

				sb.append("\n");
				for (int i = 0; i < indentLevel; i++) {
					sb.append("\t");
				}
				sb.append("}");
			}

		}

		public static class Aos implements BerType, Serializable {

			private static final long serialVersionUID = 1L;

			public static class SEQUENCE implements BerType, Serializable {

				private static final long serialVersionUID = 1L;

				public static class AosVcSelection implements BerType, Serializable {

					private static final long serialVersionUID = 1L;

					public byte[] code = null;
					public static class SelectedAosVcids implements BerType, Serializable {

						private static final long serialVersionUID = 1L;

						public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);
						public byte[] code = null;
						private List<BerInteger> seqOf = null;

						public SelectedAosVcids() {
							seqOf = new ArrayList<BerInteger>();
						}

						public SelectedAosVcids(byte[] code) {
							this.code = code;
						}

						public List<BerInteger> getBerInteger() {
							if (seqOf == null) {
								seqOf = new ArrayList<BerInteger>();
							}
							return seqOf;
						}

						public int encode(OutputStream reverseOS) throws IOException {
							return encode(reverseOS, true);
						}

						public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

							if (code != null) {
								for (int i = code.length - 1; i >= 0; i--) {
									reverseOS.write(code[i]);
								}
								if (withTag) {
									return tag.encode(reverseOS) + code.length;
								}
								return code.length;
							}

							int codeLength = 0;
							for (int i = (seqOf.size() - 1); i >= 0; i--) {
								codeLength += seqOf.get(i).encode(reverseOS, true);
							}

							codeLength += BerLength.encodeLength(reverseOS, codeLength);

							if (withTag) {
								codeLength += tag.encode(reverseOS);
							}

							return codeLength;
						}

						public int decode(InputStream is) throws IOException {
							return decode(is, true);
						}

						public int decode(InputStream is, boolean withTag) throws IOException {
							int codeLength = 0;
							int subCodeLength = 0;
							if (withTag) {
								codeLength += tag.decodeAndCheck(is);
							}

							BerLength length = new BerLength();
							codeLength += length.decode(is);
							int totalLength = length.val;

							while (subCodeLength < totalLength) {
								BerInteger element = new BerInteger();
								subCodeLength += element.decode(is, true);
								seqOf.add(element);
							}
							if (subCodeLength != totalLength) {
								throw new IOException("Decoded SequenceOf or SetOf has wrong length. Expected " + totalLength + " but has " + subCodeLength);

							}
							codeLength += subCodeLength;

							return codeLength;
						}

						public void encodeAndSave(int encodingSizeGuess) throws IOException {
							ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
							encode(reverseOS, false);
							code = reverseOS.getArray();
						}

						public String toString() {
							StringBuilder sb = new StringBuilder();
							appendAsString(sb, 0);
							return sb.toString();
						}

						public void appendAsString(StringBuilder sb, int indentLevel) {

							sb.append("{\n");
							for (int i = 0; i < indentLevel + 1; i++) {
								sb.append("\t");
							}
							if (seqOf == null) {
								sb.append("null");
							}
							else {
								Iterator<BerInteger> it = seqOf.iterator();
								if (it.hasNext()) {
									sb.append(it.next());
									while (it.hasNext()) {
										sb.append(",\n");
										for (int i = 0; i < indentLevel + 1; i++) {
											sb.append("\t");
										}
										sb.append(it.next());
									}
								}
							}

							sb.append("\n");
							for (int i = 0; i < indentLevel; i++) {
								sb.append("\t");
							}
							sb.append("}");
						}

					}

					private BerNull allAosVcids = null;
					private SelectedAosVcids selectedAosVcids = null;
					
					public AosVcSelection() {
					}

					public AosVcSelection(byte[] code) {
						this.code = code;
					}

					public void setAllAosVcids(BerNull allAosVcids) {
						this.allAosVcids = allAosVcids;
					}

					public BerNull getAllAosVcids() {
						return allAosVcids;
					}

					public void setSelectedAosVcids(SelectedAosVcids selectedAosVcids) {
						this.selectedAosVcids = selectedAosVcids;
					}

					public SelectedAosVcids getSelectedAosVcids() {
						return selectedAosVcids;
					}

					public int encode(OutputStream reverseOS) throws IOException {

						if (code != null) {
							for (int i = code.length - 1; i >= 0; i--) {
								reverseOS.write(code[i]);
							}
							return code.length;
						}

						int codeLength = 0;
						if (selectedAosVcids != null) {
							codeLength += selectedAosVcids.encode(reverseOS, false);
							// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
							reverseOS.write(0xA1);
							codeLength += 1;
							return codeLength;
						}
						
						if (allAosVcids != null) {
							codeLength += allAosVcids.encode(reverseOS, false);
							// write tag: CONTEXT_CLASS, PRIMITIVE, 0
							reverseOS.write(0x80);
							codeLength += 1;
							return codeLength;
						}
						
						throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
					}

					public int decode(InputStream is) throws IOException {
						return decode(is, null);
					}

					public int decode(InputStream is, BerTag berTag) throws IOException {

						int codeLength = 0;
						BerTag passedTag = berTag;

						if (berTag == null) {
							berTag = new BerTag();
							codeLength += berTag.decode(is);
						}

						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
							allAosVcids = new BerNull();
							codeLength += allAosVcids.decode(is, false);
							return codeLength;
						}

						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
							selectedAosVcids = new SelectedAosVcids();
							codeLength += selectedAosVcids.decode(is, false);
							return codeLength;
						}

						if (passedTag != null) {
							return 0;
						}

						throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
					}

					public void encodeAndSave(int encodingSizeGuess) throws IOException {
						ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
						encode(reverseOS);
						code = reverseOS.getArray();
					}

					public String toString() {
						StringBuilder sb = new StringBuilder();
						appendAsString(sb, 0);
						return sb.toString();
					}

					public void appendAsString(StringBuilder sb, int indentLevel) {

						if (allAosVcids != null) {
							sb.append("allAosVcids: ").append(allAosVcids);
							return;
						}

						if (selectedAosVcids != null) {
							sb.append("selectedAosVcids: ");
							selectedAosVcids.appendAsString(sb, indentLevel + 1);
							return;
						}

						sb.append("<none>");
					}

				}

				public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

				public byte[] code = null;
				private BerInteger aosScid = null;
				private AosVcSelection aosVcSelection = null;
				
				public SEQUENCE() {
				}

				public SEQUENCE(byte[] code) {
					this.code = code;
				}

				public void setAosScid(BerInteger aosScid) {
					this.aosScid = aosScid;
				}

				public BerInteger getAosScid() {
					return aosScid;
				}

				public void setAosVcSelection(AosVcSelection aosVcSelection) {
					this.aosVcSelection = aosVcSelection;
				}

				public AosVcSelection getAosVcSelection() {
					return aosVcSelection;
				}

				public int encode(OutputStream reverseOS) throws IOException {
					return encode(reverseOS, true);
				}

				public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

					if (code != null) {
						for (int i = code.length - 1; i >= 0; i--) {
							reverseOS.write(code[i]);
						}
						if (withTag) {
							return tag.encode(reverseOS) + code.length;
						}
						return code.length;
					}

					int codeLength = 0;
					codeLength += aosVcSelection.encode(reverseOS);
					
					codeLength += aosScid.encode(reverseOS, true);
					
					codeLength += BerLength.encodeLength(reverseOS, codeLength);

					if (withTag) {
						codeLength += tag.encode(reverseOS);
					}

					return codeLength;

				}

				public int decode(InputStream is) throws IOException {
					return decode(is, true);
				}

				public int decode(InputStream is, boolean withTag) throws IOException {
					int codeLength = 0;
					int subCodeLength = 0;
					BerTag berTag = new BerTag();

					if (withTag) {
						codeLength += tag.decodeAndCheck(is);
					}

					BerLength length = new BerLength();
					codeLength += length.decode(is);

					int totalLength = length.val;
					codeLength += totalLength;

					subCodeLength += berTag.decode(is);
					if (berTag.equals(BerInteger.tag)) {
						aosScid = new BerInteger();
						subCodeLength += aosScid.decode(is, false);
						subCodeLength += berTag.decode(is);
					}
					else {
						throw new IOException("Tag does not match the mandatory sequence element tag.");
					}
					
					aosVcSelection = new AosVcSelection();
					subCodeLength += aosVcSelection.decode(is, berTag);
					if (subCodeLength == totalLength) {
						return codeLength;
					}
					throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

					
				}

				public void encodeAndSave(int encodingSizeGuess) throws IOException {
					ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
					encode(reverseOS, false);
					code = reverseOS.getArray();
				}

				public String toString() {
					StringBuilder sb = new StringBuilder();
					appendAsString(sb, 0);
					return sb.toString();
				}

				public void appendAsString(StringBuilder sb, int indentLevel) {

					sb.append("{");
					sb.append("\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (aosScid != null) {
						sb.append("aosScid: ").append(aosScid);
					}
					else {
						sb.append("aosScid: <empty-required-field>");
					}
					
					sb.append(",\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (aosVcSelection != null) {
						sb.append("aosVcSelection: ");
						aosVcSelection.appendAsString(sb, indentLevel + 1);
					}
					else {
						sb.append("aosVcSelection: <empty-required-field>");
					}
					
					sb.append("\n");
					for (int i = 0; i < indentLevel; i++) {
						sb.append("\t");
					}
					sb.append("}");
				}

			}

			public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);
			public byte[] code = null;
			private List<SEQUENCE> seqOf = null;

			public Aos() {
				seqOf = new ArrayList<SEQUENCE>();
			}

			public Aos(byte[] code) {
				this.code = code;
			}

			public List<SEQUENCE> getSEQUENCE() {
				if (seqOf == null) {
					seqOf = new ArrayList<SEQUENCE>();
				}
				return seqOf;
			}

			public int encode(OutputStream reverseOS) throws IOException {
				return encode(reverseOS, true);
			}

			public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

				if (code != null) {
					for (int i = code.length - 1; i >= 0; i--) {
						reverseOS.write(code[i]);
					}
					if (withTag) {
						return tag.encode(reverseOS) + code.length;
					}
					return code.length;
				}

				int codeLength = 0;
				for (int i = (seqOf.size() - 1); i >= 0; i--) {
					codeLength += seqOf.get(i).encode(reverseOS, true);
				}

				codeLength += BerLength.encodeLength(reverseOS, codeLength);

				if (withTag) {
					codeLength += tag.encode(reverseOS);
				}

				return codeLength;
			}

			public int decode(InputStream is) throws IOException {
				return decode(is, true);
			}

			public int decode(InputStream is, boolean withTag) throws IOException {
				int codeLength = 0;
				int subCodeLength = 0;
				if (withTag) {
					codeLength += tag.decodeAndCheck(is);
				}

				BerLength length = new BerLength();
				codeLength += length.decode(is);
				int totalLength = length.val;

				while (subCodeLength < totalLength) {
					SEQUENCE element = new SEQUENCE();
					subCodeLength += element.decode(is, true);
					seqOf.add(element);
				}
				if (subCodeLength != totalLength) {
					throw new IOException("Decoded SequenceOf or SetOf has wrong length. Expected " + totalLength + " but has " + subCodeLength);

				}
				codeLength += subCodeLength;

				return codeLength;
			}

			public void encodeAndSave(int encodingSizeGuess) throws IOException {
				ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
				encode(reverseOS, false);
				code = reverseOS.getArray();
			}

			public String toString() {
				StringBuilder sb = new StringBuilder();
				appendAsString(sb, 0);
				return sb.toString();
			}

			public void appendAsString(StringBuilder sb, int indentLevel) {

				sb.append("{\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				if (seqOf == null) {
					sb.append("null");
				}
				else {
					Iterator<SEQUENCE> it = seqOf.iterator();
					if (it.hasNext()) {
						it.next().appendAsString(sb, indentLevel + 1);
						while (it.hasNext()) {
							sb.append(",\n");
							for (int i = 0; i < indentLevel + 1; i++) {
								sb.append("\t");
							}
							it.next().appendAsString(sb, indentLevel + 1);
						}
					}
				}

				sb.append("\n");
				for (int i = 0; i < indentLevel; i++) {
					sb.append("\t");
				}
				sb.append("}");
			}

		}

		public static class Uslp implements BerType, Serializable {

			private static final long serialVersionUID = 1L;

			public static class SEQUENCE implements BerType, Serializable {

				private static final long serialVersionUID = 1L;

				public static class UslpVcSelection implements BerType, Serializable {

					private static final long serialVersionUID = 1L;

					public byte[] code = null;
					public static class SelectedUslpVcids implements BerType, Serializable {

						private static final long serialVersionUID = 1L;

						public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);
						public byte[] code = null;
						private List<BerInteger> seqOf = null;

						public SelectedUslpVcids() {
							seqOf = new ArrayList<BerInteger>();
						}

						public SelectedUslpVcids(byte[] code) {
							this.code = code;
						}

						public List<BerInteger> getBerInteger() {
							if (seqOf == null) {
								seqOf = new ArrayList<BerInteger>();
							}
							return seqOf;
						}

						public int encode(OutputStream reverseOS) throws IOException {
							return encode(reverseOS, true);
						}

						public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

							if (code != null) {
								for (int i = code.length - 1; i >= 0; i--) {
									reverseOS.write(code[i]);
								}
								if (withTag) {
									return tag.encode(reverseOS) + code.length;
								}
								return code.length;
							}

							int codeLength = 0;
							for (int i = (seqOf.size() - 1); i >= 0; i--) {
								codeLength += seqOf.get(i).encode(reverseOS, true);
							}

							codeLength += BerLength.encodeLength(reverseOS, codeLength);

							if (withTag) {
								codeLength += tag.encode(reverseOS);
							}

							return codeLength;
						}

						public int decode(InputStream is) throws IOException {
							return decode(is, true);
						}

						public int decode(InputStream is, boolean withTag) throws IOException {
							int codeLength = 0;
							int subCodeLength = 0;
							if (withTag) {
								codeLength += tag.decodeAndCheck(is);
							}

							BerLength length = new BerLength();
							codeLength += length.decode(is);
							int totalLength = length.val;

							while (subCodeLength < totalLength) {
								BerInteger element = new BerInteger();
								subCodeLength += element.decode(is, true);
								seqOf.add(element);
							}
							if (subCodeLength != totalLength) {
								throw new IOException("Decoded SequenceOf or SetOf has wrong length. Expected " + totalLength + " but has " + subCodeLength);

							}
							codeLength += subCodeLength;

							return codeLength;
						}

						public void encodeAndSave(int encodingSizeGuess) throws IOException {
							ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
							encode(reverseOS, false);
							code = reverseOS.getArray();
						}

						public String toString() {
							StringBuilder sb = new StringBuilder();
							appendAsString(sb, 0);
							return sb.toString();
						}

						public void appendAsString(StringBuilder sb, int indentLevel) {

							sb.append("{\n");
							for (int i = 0; i < indentLevel + 1; i++) {
								sb.append("\t");
							}
							if (seqOf == null) {
								sb.append("null");
							}
							else {
								Iterator<BerInteger> it = seqOf.iterator();
								if (it.hasNext()) {
									sb.append(it.next());
									while (it.hasNext()) {
										sb.append(",\n");
										for (int i = 0; i < indentLevel + 1; i++) {
											sb.append("\t");
										}
										sb.append(it.next());
									}
								}
							}

							sb.append("\n");
							for (int i = 0; i < indentLevel; i++) {
								sb.append("\t");
							}
							sb.append("}");
						}

					}

					private BerNull allUslpVcids = null;
					private SelectedUslpVcids selectedUslpVcids = null;
					
					public UslpVcSelection() {
					}

					public UslpVcSelection(byte[] code) {
						this.code = code;
					}

					public void setAllUslpVcids(BerNull allUslpVcids) {
						this.allUslpVcids = allUslpVcids;
					}

					public BerNull getAllUslpVcids() {
						return allUslpVcids;
					}

					public void setSelectedUslpVcids(SelectedUslpVcids selectedUslpVcids) {
						this.selectedUslpVcids = selectedUslpVcids;
					}

					public SelectedUslpVcids getSelectedUslpVcids() {
						return selectedUslpVcids;
					}

					public int encode(OutputStream reverseOS) throws IOException {

						if (code != null) {
							for (int i = code.length - 1; i >= 0; i--) {
								reverseOS.write(code[i]);
							}
							return code.length;
						}

						int codeLength = 0;
						if (selectedUslpVcids != null) {
							codeLength += selectedUslpVcids.encode(reverseOS, false);
							// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
							reverseOS.write(0xA1);
							codeLength += 1;
							return codeLength;
						}
						
						if (allUslpVcids != null) {
							codeLength += allUslpVcids.encode(reverseOS, false);
							// write tag: CONTEXT_CLASS, PRIMITIVE, 0
							reverseOS.write(0x80);
							codeLength += 1;
							return codeLength;
						}
						
						throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
					}

					public int decode(InputStream is) throws IOException {
						return decode(is, null);
					}

					public int decode(InputStream is, BerTag berTag) throws IOException {

						int codeLength = 0;
						BerTag passedTag = berTag;

						if (berTag == null) {
							berTag = new BerTag();
							codeLength += berTag.decode(is);
						}

						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
							allUslpVcids = new BerNull();
							codeLength += allUslpVcids.decode(is, false);
							return codeLength;
						}

						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
							selectedUslpVcids = new SelectedUslpVcids();
							codeLength += selectedUslpVcids.decode(is, false);
							return codeLength;
						}

						if (passedTag != null) {
							return 0;
						}

						throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
					}

					public void encodeAndSave(int encodingSizeGuess) throws IOException {
						ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
						encode(reverseOS);
						code = reverseOS.getArray();
					}

					public String toString() {
						StringBuilder sb = new StringBuilder();
						appendAsString(sb, 0);
						return sb.toString();
					}

					public void appendAsString(StringBuilder sb, int indentLevel) {

						if (allUslpVcids != null) {
							sb.append("allUslpVcids: ").append(allUslpVcids);
							return;
						}

						if (selectedUslpVcids != null) {
							sb.append("selectedUslpVcids: ");
							selectedUslpVcids.appendAsString(sb, indentLevel + 1);
							return;
						}

						sb.append("<none>");
					}

				}

				public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

				public byte[] code = null;
				private BerInteger uslpScid = null;
				private UslpVcSelection uslpVcSelection = null;
				
				public SEQUENCE() {
				}

				public SEQUENCE(byte[] code) {
					this.code = code;
				}

				public void setUslpScid(BerInteger uslpScid) {
					this.uslpScid = uslpScid;
				}

				public BerInteger getUslpScid() {
					return uslpScid;
				}

				public void setUslpVcSelection(UslpVcSelection uslpVcSelection) {
					this.uslpVcSelection = uslpVcSelection;
				}

				public UslpVcSelection getUslpVcSelection() {
					return uslpVcSelection;
				}

				public int encode(OutputStream reverseOS) throws IOException {
					return encode(reverseOS, true);
				}

				public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

					if (code != null) {
						for (int i = code.length - 1; i >= 0; i--) {
							reverseOS.write(code[i]);
						}
						if (withTag) {
							return tag.encode(reverseOS) + code.length;
						}
						return code.length;
					}

					int codeLength = 0;
					codeLength += uslpVcSelection.encode(reverseOS);
					
					codeLength += uslpScid.encode(reverseOS, true);
					
					codeLength += BerLength.encodeLength(reverseOS, codeLength);

					if (withTag) {
						codeLength += tag.encode(reverseOS);
					}

					return codeLength;

				}

				public int decode(InputStream is) throws IOException {
					return decode(is, true);
				}

				public int decode(InputStream is, boolean withTag) throws IOException {
					int codeLength = 0;
					int subCodeLength = 0;
					BerTag berTag = new BerTag();

					if (withTag) {
						codeLength += tag.decodeAndCheck(is);
					}

					BerLength length = new BerLength();
					codeLength += length.decode(is);

					int totalLength = length.val;
					codeLength += totalLength;

					subCodeLength += berTag.decode(is);
					if (berTag.equals(BerInteger.tag)) {
						uslpScid = new BerInteger();
						subCodeLength += uslpScid.decode(is, false);
						subCodeLength += berTag.decode(is);
					}
					else {
						throw new IOException("Tag does not match the mandatory sequence element tag.");
					}
					
					uslpVcSelection = new UslpVcSelection();
					subCodeLength += uslpVcSelection.decode(is, berTag);
					if (subCodeLength == totalLength) {
						return codeLength;
					}
					throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

					
				}

				public void encodeAndSave(int encodingSizeGuess) throws IOException {
					ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
					encode(reverseOS, false);
					code = reverseOS.getArray();
				}

				public String toString() {
					StringBuilder sb = new StringBuilder();
					appendAsString(sb, 0);
					return sb.toString();
				}

				public void appendAsString(StringBuilder sb, int indentLevel) {

					sb.append("{");
					sb.append("\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (uslpScid != null) {
						sb.append("uslpScid: ").append(uslpScid);
					}
					else {
						sb.append("uslpScid: <empty-required-field>");
					}
					
					sb.append(",\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (uslpVcSelection != null) {
						sb.append("uslpVcSelection: ");
						uslpVcSelection.appendAsString(sb, indentLevel + 1);
					}
					else {
						sb.append("uslpVcSelection: <empty-required-field>");
					}
					
					sb.append("\n");
					for (int i = 0; i < indentLevel; i++) {
						sb.append("\t");
					}
					sb.append("}");
				}

			}

			public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);
			public byte[] code = null;
			private List<SEQUENCE> seqOf = null;

			public Uslp() {
				seqOf = new ArrayList<SEQUENCE>();
			}

			public Uslp(byte[] code) {
				this.code = code;
			}

			public List<SEQUENCE> getSEQUENCE() {
				if (seqOf == null) {
					seqOf = new ArrayList<SEQUENCE>();
				}
				return seqOf;
			}

			public int encode(OutputStream reverseOS) throws IOException {
				return encode(reverseOS, true);
			}

			public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

				if (code != null) {
					for (int i = code.length - 1; i >= 0; i--) {
						reverseOS.write(code[i]);
					}
					if (withTag) {
						return tag.encode(reverseOS) + code.length;
					}
					return code.length;
				}

				int codeLength = 0;
				for (int i = (seqOf.size() - 1); i >= 0; i--) {
					codeLength += seqOf.get(i).encode(reverseOS, true);
				}

				codeLength += BerLength.encodeLength(reverseOS, codeLength);

				if (withTag) {
					codeLength += tag.encode(reverseOS);
				}

				return codeLength;
			}

			public int decode(InputStream is) throws IOException {
				return decode(is, true);
			}

			public int decode(InputStream is, boolean withTag) throws IOException {
				int codeLength = 0;
				int subCodeLength = 0;
				if (withTag) {
					codeLength += tag.decodeAndCheck(is);
				}

				BerLength length = new BerLength();
				codeLength += length.decode(is);
				int totalLength = length.val;

				while (subCodeLength < totalLength) {
					SEQUENCE element = new SEQUENCE();
					subCodeLength += element.decode(is, true);
					seqOf.add(element);
				}
				if (subCodeLength != totalLength) {
					throw new IOException("Decoded SequenceOf or SetOf has wrong length. Expected " + totalLength + " but has " + subCodeLength);

				}
				codeLength += subCodeLength;

				return codeLength;
			}

			public void encodeAndSave(int encodingSizeGuess) throws IOException {
				ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
				encode(reverseOS, false);
				code = reverseOS.getArray();
			}

			public String toString() {
				StringBuilder sb = new StringBuilder();
				appendAsString(sb, 0);
				return sb.toString();
			}

			public void appendAsString(StringBuilder sb, int indentLevel) {

				sb.append("{\n");
				for (int i = 0; i < indentLevel + 1; i++) {
					sb.append("\t");
				}
				if (seqOf == null) {
					sb.append("null");
				}
				else {
					Iterator<SEQUENCE> it = seqOf.iterator();
					if (it.hasNext()) {
						it.next().appendAsString(sb, indentLevel + 1);
						while (it.hasNext()) {
							sb.append(",\n");
							for (int i = 0; i < indentLevel + 1; i++) {
								sb.append("\t");
							}
							it.next().appendAsString(sb, indentLevel + 1);
						}
					}
				}

				sb.append("\n");
				for (int i = 0; i < indentLevel; i++) {
					sb.append("\t");
				}
				sb.append("}");
			}

		}

		private TM tM = null;
		private Aos aos = null;
		private Uslp uslp = null;
		
		public ChannelList() {
		}

		public ChannelList(byte[] code) {
			this.code = code;
		}

		public void setTM(TM tM) {
			this.tM = tM;
		}

		public TM getTM() {
			return tM;
		}

		public void setAos(Aos aos) {
			this.aos = aos;
		}

		public Aos getAos() {
			return aos;
		}

		public void setUslp(Uslp uslp) {
			this.uslp = uslp;
		}

		public Uslp getUslp() {
			return uslp;
		}

		public int encode(OutputStream reverseOS) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				return code.length;
			}

			int codeLength = 0;
			if (uslp != null) {
				codeLength += uslp.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, CONSTRUCTED, 2
				reverseOS.write(0xA2);
				codeLength += 1;
				return codeLength;
			}
			
			if (aos != null) {
				codeLength += aos.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
				reverseOS.write(0xA1);
				codeLength += 1;
				return codeLength;
			}
			
			if (tM != null) {
				codeLength += tM.encode(reverseOS, false);
				// write tag: CONTEXT_CLASS, CONSTRUCTED, 0
				reverseOS.write(0xA0);
				codeLength += 1;
				return codeLength;
			}
			
			throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
		}

		public int decode(InputStream is) throws IOException {
			return decode(is, null);
		}

		public int decode(InputStream is, BerTag berTag) throws IOException {

			int codeLength = 0;
			BerTag passedTag = berTag;

			if (berTag == null) {
				berTag = new BerTag();
				codeLength += berTag.decode(is);
			}

			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 0)) {
				tM = new TM();
				codeLength += tM.decode(is, false);
				return codeLength;
			}

			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
				aos = new Aos();
				codeLength += aos.decode(is, false);
				return codeLength;
			}

			if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 2)) {
				uslp = new Uslp();
				codeLength += uslp.decode(is, false);
				return codeLength;
			}

			if (passedTag != null) {
				return 0;
			}

			throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			if (tM != null) {
				sb.append("tM: ");
				tM.appendAsString(sb, indentLevel + 1);
				return;
			}

			if (aos != null) {
				sb.append("aos: ");
				aos.appendAsString(sb, indentLevel + 1);
				return;
			}

			if (uslp != null) {
				sb.append("uslp: ");
				uslp.appendAsString(sb, indentLevel + 1);
				return;
			}

			sb.append("<none>");
		}

	}

	private BerNull all = null;
	private ChannelList channelList = null;
	
	public FrameDataSinkStorageSelection() {
	}

	public FrameDataSinkStorageSelection(byte[] code) {
		this.code = code;
	}

	public void setAll(BerNull all) {
		this.all = all;
	}

	public BerNull getAll() {
		return all;
	}

	public void setChannelList(ChannelList channelList) {
		this.channelList = channelList;
	}

	public ChannelList getChannelList() {
		return channelList;
	}

	public int encode(OutputStream reverseOS) throws IOException {

		if (code != null) {
			for (int i = code.length - 1; i >= 0; i--) {
				reverseOS.write(code[i]);
			}
			return code.length;
		}

		int codeLength = 0;
		int sublength;

		if (channelList != null) {
			sublength = channelList.encode(reverseOS);
			codeLength += sublength;
			codeLength += BerLength.encodeLength(reverseOS, sublength);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
			reverseOS.write(0xA1);
			codeLength += 1;
			return codeLength;
		}
		
		if (all != null) {
			codeLength += all.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, PRIMITIVE, 0
			reverseOS.write(0x80);
			codeLength += 1;
			return codeLength;
		}
		
		throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
	}

	public int decode(InputStream is) throws IOException {
		return decode(is, null);
	}

	public int decode(InputStream is, BerTag berTag) throws IOException {

		int codeLength = 0;
		BerTag passedTag = berTag;

		if (berTag == null) {
			berTag = new BerTag();
			codeLength += berTag.decode(is);
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
			all = new BerNull();
			codeLength += all.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
			codeLength += BerLength.skip(is);
			channelList = new ChannelList();
			codeLength += channelList.decode(is, null);
			return codeLength;
		}

		if (passedTag != null) {
			return 0;
		}

		throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
	}

	public void encodeAndSave(int encodingSizeGuess) throws IOException {
		ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
		encode(reverseOS);
		code = reverseOS.getArray();
	}

	public String toString() {
		StringBuilder sb = new StringBuilder();
		appendAsString(sb, 0);
		return sb.toString();
	}

	public void appendAsString(StringBuilder sb, int indentLevel) {

		if (all != null) {
			sb.append("all: ").append(all);
			return;
		}

		if (channelList != null) {
			sb.append("channelList: ");
			channelList.appendAsString(sb, indentLevel + 1);
			return;
		}

		sb.append("<none>");
	}

}

