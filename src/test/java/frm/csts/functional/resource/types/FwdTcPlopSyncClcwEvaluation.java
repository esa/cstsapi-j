/**
 * This class file was automatically generated by jASN1 v1.11.2 (http://www.beanit.com)
 */

package frm.csts.functional.resource.types;

import java.io.IOException;
import java.io.EOFException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.io.Serializable;
import com.beanit.jasn1.ber.*;
import com.beanit.jasn1.ber.types.*;
import com.beanit.jasn1.ber.types.string.*;


public class FwdTcPlopSyncClcwEvaluation implements BerType, Serializable {

	private static final long serialVersionUID = 1L;

	public byte[] code = null;
	public static class Evaluation implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static class ClcwSource implements BerType, Serializable {

			private static final long serialVersionUID = 1L;

			public byte[] code = null;
			public static class Tfvn0 implements BerType, Serializable {

				private static final long serialVersionUID = 1L;

				public static class Vcid implements BerType, Serializable {

					private static final long serialVersionUID = 1L;

					public byte[] code = null;
					private BerNull masterChannel = null;
					private BerInteger virtualChannel = null;
					
					public Vcid() {
					}

					public Vcid(byte[] code) {
						this.code = code;
					}

					public void setMasterChannel(BerNull masterChannel) {
						this.masterChannel = masterChannel;
					}

					public BerNull getMasterChannel() {
						return masterChannel;
					}

					public void setVirtualChannel(BerInteger virtualChannel) {
						this.virtualChannel = virtualChannel;
					}

					public BerInteger getVirtualChannel() {
						return virtualChannel;
					}

					public int encode(OutputStream reverseOS) throws IOException {

						if (code != null) {
							for (int i = code.length - 1; i >= 0; i--) {
								reverseOS.write(code[i]);
							}
							return code.length;
						}

						int codeLength = 0;
						if (virtualChannel != null) {
							codeLength += virtualChannel.encode(reverseOS, false);
							// write tag: CONTEXT_CLASS, PRIMITIVE, 1
							reverseOS.write(0x81);
							codeLength += 1;
							return codeLength;
						}
						
						if (masterChannel != null) {
							codeLength += masterChannel.encode(reverseOS, false);
							// write tag: CONTEXT_CLASS, PRIMITIVE, 0
							reverseOS.write(0x80);
							codeLength += 1;
							return codeLength;
						}
						
						throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
					}

					public int decode(InputStream is) throws IOException {
						return decode(is, null);
					}

					public int decode(InputStream is, BerTag berTag) throws IOException {

						int codeLength = 0;
						BerTag passedTag = berTag;

						if (berTag == null) {
							berTag = new BerTag();
							codeLength += berTag.decode(is);
						}

						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
							masterChannel = new BerNull();
							codeLength += masterChannel.decode(is, false);
							return codeLength;
						}

						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
							virtualChannel = new BerInteger();
							codeLength += virtualChannel.decode(is, false);
							return codeLength;
						}

						if (passedTag != null) {
							return 0;
						}

						throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
					}

					public void encodeAndSave(int encodingSizeGuess) throws IOException {
						ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
						encode(reverseOS);
						code = reverseOS.getArray();
					}

					public String toString() {
						StringBuilder sb = new StringBuilder();
						appendAsString(sb, 0);
						return sb.toString();
					}

					public void appendAsString(StringBuilder sb, int indentLevel) {

						if (masterChannel != null) {
							sb.append("masterChannel: ").append(masterChannel);
							return;
						}

						if (virtualChannel != null) {
							sb.append("virtualChannel: ").append(virtualChannel);
							return;
						}

						sb.append("<none>");
					}

				}

				public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

				public byte[] code = null;
				private BerInteger tfvn = null;
				private BerInteger scid = null;
				private Vcid vcid = null;
				
				public Tfvn0() {
				}

				public Tfvn0(byte[] code) {
					this.code = code;
				}

				public void setTfvn(BerInteger tfvn) {
					this.tfvn = tfvn;
				}

				public BerInteger getTfvn() {
					return tfvn;
				}

				public void setScid(BerInteger scid) {
					this.scid = scid;
				}

				public BerInteger getScid() {
					return scid;
				}

				public void setVcid(Vcid vcid) {
					this.vcid = vcid;
				}

				public Vcid getVcid() {
					return vcid;
				}

				public int encode(OutputStream reverseOS) throws IOException {
					return encode(reverseOS, true);
				}

				public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

					if (code != null) {
						for (int i = code.length - 1; i >= 0; i--) {
							reverseOS.write(code[i]);
						}
						if (withTag) {
							return tag.encode(reverseOS) + code.length;
						}
						return code.length;
					}

					int codeLength = 0;
					codeLength += vcid.encode(reverseOS);
					
					codeLength += scid.encode(reverseOS, true);
					
					codeLength += tfvn.encode(reverseOS, true);
					
					codeLength += BerLength.encodeLength(reverseOS, codeLength);

					if (withTag) {
						codeLength += tag.encode(reverseOS);
					}

					return codeLength;

				}

				public int decode(InputStream is) throws IOException {
					return decode(is, true);
				}

				public int decode(InputStream is, boolean withTag) throws IOException {
					int codeLength = 0;
					int subCodeLength = 0;
					BerTag berTag = new BerTag();

					if (withTag) {
						codeLength += tag.decodeAndCheck(is);
					}

					BerLength length = new BerLength();
					codeLength += length.decode(is);

					int totalLength = length.val;
					codeLength += totalLength;

					subCodeLength += berTag.decode(is);
					if (berTag.equals(BerInteger.tag)) {
						tfvn = new BerInteger();
						subCodeLength += tfvn.decode(is, false);
						subCodeLength += berTag.decode(is);
					}
					else {
						throw new IOException("Tag does not match the mandatory sequence element tag.");
					}
					
					if (berTag.equals(BerInteger.tag)) {
						scid = new BerInteger();
						subCodeLength += scid.decode(is, false);
						subCodeLength += berTag.decode(is);
					}
					else {
						throw new IOException("Tag does not match the mandatory sequence element tag.");
					}
					
					vcid = new Vcid();
					subCodeLength += vcid.decode(is, berTag);
					if (subCodeLength == totalLength) {
						return codeLength;
					}
					throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

					
				}

				public void encodeAndSave(int encodingSizeGuess) throws IOException {
					ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
					encode(reverseOS, false);
					code = reverseOS.getArray();
				}

				public String toString() {
					StringBuilder sb = new StringBuilder();
					appendAsString(sb, 0);
					return sb.toString();
				}

				public void appendAsString(StringBuilder sb, int indentLevel) {

					sb.append("{");
					sb.append("\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (tfvn != null) {
						sb.append("tfvn: ").append(tfvn);
					}
					else {
						sb.append("tfvn: <empty-required-field>");
					}
					
					sb.append(",\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (scid != null) {
						sb.append("scid: ").append(scid);
					}
					else {
						sb.append("scid: <empty-required-field>");
					}
					
					sb.append(",\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (vcid != null) {
						sb.append("vcid: ");
						vcid.appendAsString(sb, indentLevel + 1);
					}
					else {
						sb.append("vcid: <empty-required-field>");
					}
					
					sb.append("\n");
					for (int i = 0; i < indentLevel; i++) {
						sb.append("\t");
					}
					sb.append("}");
				}

			}

			public static class Tfvn1 implements BerType, Serializable {

				private static final long serialVersionUID = 1L;

				public static class Vcid implements BerType, Serializable {

					private static final long serialVersionUID = 1L;

					public byte[] code = null;
					private BerNull masterChannel = null;
					private BerInteger virtualChannel = null;
					
					public Vcid() {
					}

					public Vcid(byte[] code) {
						this.code = code;
					}

					public void setMasterChannel(BerNull masterChannel) {
						this.masterChannel = masterChannel;
					}

					public BerNull getMasterChannel() {
						return masterChannel;
					}

					public void setVirtualChannel(BerInteger virtualChannel) {
						this.virtualChannel = virtualChannel;
					}

					public BerInteger getVirtualChannel() {
						return virtualChannel;
					}

					public int encode(OutputStream reverseOS) throws IOException {

						if (code != null) {
							for (int i = code.length - 1; i >= 0; i--) {
								reverseOS.write(code[i]);
							}
							return code.length;
						}

						int codeLength = 0;
						if (virtualChannel != null) {
							codeLength += virtualChannel.encode(reverseOS, false);
							// write tag: CONTEXT_CLASS, PRIMITIVE, 1
							reverseOS.write(0x81);
							codeLength += 1;
							return codeLength;
						}
						
						if (masterChannel != null) {
							codeLength += masterChannel.encode(reverseOS, false);
							// write tag: CONTEXT_CLASS, PRIMITIVE, 0
							reverseOS.write(0x80);
							codeLength += 1;
							return codeLength;
						}
						
						throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
					}

					public int decode(InputStream is) throws IOException {
						return decode(is, null);
					}

					public int decode(InputStream is, BerTag berTag) throws IOException {

						int codeLength = 0;
						BerTag passedTag = berTag;

						if (berTag == null) {
							berTag = new BerTag();
							codeLength += berTag.decode(is);
						}

						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
							masterChannel = new BerNull();
							codeLength += masterChannel.decode(is, false);
							return codeLength;
						}

						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
							virtualChannel = new BerInteger();
							codeLength += virtualChannel.decode(is, false);
							return codeLength;
						}

						if (passedTag != null) {
							return 0;
						}

						throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
					}

					public void encodeAndSave(int encodingSizeGuess) throws IOException {
						ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
						encode(reverseOS);
						code = reverseOS.getArray();
					}

					public String toString() {
						StringBuilder sb = new StringBuilder();
						appendAsString(sb, 0);
						return sb.toString();
					}

					public void appendAsString(StringBuilder sb, int indentLevel) {

						if (masterChannel != null) {
							sb.append("masterChannel: ").append(masterChannel);
							return;
						}

						if (virtualChannel != null) {
							sb.append("virtualChannel: ").append(virtualChannel);
							return;
						}

						sb.append("<none>");
					}

				}

				public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

				public byte[] code = null;
				private BerInteger tfvn = null;
				private BerInteger scid = null;
				private Vcid vcid = null;
				
				public Tfvn1() {
				}

				public Tfvn1(byte[] code) {
					this.code = code;
				}

				public void setTfvn(BerInteger tfvn) {
					this.tfvn = tfvn;
				}

				public BerInteger getTfvn() {
					return tfvn;
				}

				public void setScid(BerInteger scid) {
					this.scid = scid;
				}

				public BerInteger getScid() {
					return scid;
				}

				public void setVcid(Vcid vcid) {
					this.vcid = vcid;
				}

				public Vcid getVcid() {
					return vcid;
				}

				public int encode(OutputStream reverseOS) throws IOException {
					return encode(reverseOS, true);
				}

				public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

					if (code != null) {
						for (int i = code.length - 1; i >= 0; i--) {
							reverseOS.write(code[i]);
						}
						if (withTag) {
							return tag.encode(reverseOS) + code.length;
						}
						return code.length;
					}

					int codeLength = 0;
					codeLength += vcid.encode(reverseOS);
					
					codeLength += scid.encode(reverseOS, true);
					
					codeLength += tfvn.encode(reverseOS, true);
					
					codeLength += BerLength.encodeLength(reverseOS, codeLength);

					if (withTag) {
						codeLength += tag.encode(reverseOS);
					}

					return codeLength;

				}

				public int decode(InputStream is) throws IOException {
					return decode(is, true);
				}

				public int decode(InputStream is, boolean withTag) throws IOException {
					int codeLength = 0;
					int subCodeLength = 0;
					BerTag berTag = new BerTag();

					if (withTag) {
						codeLength += tag.decodeAndCheck(is);
					}

					BerLength length = new BerLength();
					codeLength += length.decode(is);

					int totalLength = length.val;
					codeLength += totalLength;

					subCodeLength += berTag.decode(is);
					if (berTag.equals(BerInteger.tag)) {
						tfvn = new BerInteger();
						subCodeLength += tfvn.decode(is, false);
						subCodeLength += berTag.decode(is);
					}
					else {
						throw new IOException("Tag does not match the mandatory sequence element tag.");
					}
					
					if (berTag.equals(BerInteger.tag)) {
						scid = new BerInteger();
						subCodeLength += scid.decode(is, false);
						subCodeLength += berTag.decode(is);
					}
					else {
						throw new IOException("Tag does not match the mandatory sequence element tag.");
					}
					
					vcid = new Vcid();
					subCodeLength += vcid.decode(is, berTag);
					if (subCodeLength == totalLength) {
						return codeLength;
					}
					throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

					
				}

				public void encodeAndSave(int encodingSizeGuess) throws IOException {
					ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
					encode(reverseOS, false);
					code = reverseOS.getArray();
				}

				public String toString() {
					StringBuilder sb = new StringBuilder();
					appendAsString(sb, 0);
					return sb.toString();
				}

				public void appendAsString(StringBuilder sb, int indentLevel) {

					sb.append("{");
					sb.append("\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (tfvn != null) {
						sb.append("tfvn: ").append(tfvn);
					}
					else {
						sb.append("tfvn: <empty-required-field>");
					}
					
					sb.append(",\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (scid != null) {
						sb.append("scid: ").append(scid);
					}
					else {
						sb.append("scid: <empty-required-field>");
					}
					
					sb.append(",\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (vcid != null) {
						sb.append("vcid: ");
						vcid.appendAsString(sb, indentLevel + 1);
					}
					else {
						sb.append("vcid: <empty-required-field>");
					}
					
					sb.append("\n");
					for (int i = 0; i < indentLevel; i++) {
						sb.append("\t");
					}
					sb.append("}");
				}

			}

			public static class Tfvn12 implements BerType, Serializable {

				private static final long serialVersionUID = 1L;

				public static class Vcid implements BerType, Serializable {

					private static final long serialVersionUID = 1L;

					public byte[] code = null;
					private BerNull masterChannel = null;
					private BerInteger virtualChannel = null;
					
					public Vcid() {
					}

					public Vcid(byte[] code) {
						this.code = code;
					}

					public void setMasterChannel(BerNull masterChannel) {
						this.masterChannel = masterChannel;
					}

					public BerNull getMasterChannel() {
						return masterChannel;
					}

					public void setVirtualChannel(BerInteger virtualChannel) {
						this.virtualChannel = virtualChannel;
					}

					public BerInteger getVirtualChannel() {
						return virtualChannel;
					}

					public int encode(OutputStream reverseOS) throws IOException {

						if (code != null) {
							for (int i = code.length - 1; i >= 0; i--) {
								reverseOS.write(code[i]);
							}
							return code.length;
						}

						int codeLength = 0;
						if (virtualChannel != null) {
							codeLength += virtualChannel.encode(reverseOS, false);
							// write tag: CONTEXT_CLASS, PRIMITIVE, 1
							reverseOS.write(0x81);
							codeLength += 1;
							return codeLength;
						}
						
						if (masterChannel != null) {
							codeLength += masterChannel.encode(reverseOS, false);
							// write tag: CONTEXT_CLASS, PRIMITIVE, 0
							reverseOS.write(0x80);
							codeLength += 1;
							return codeLength;
						}
						
						throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
					}

					public int decode(InputStream is) throws IOException {
						return decode(is, null);
					}

					public int decode(InputStream is, BerTag berTag) throws IOException {

						int codeLength = 0;
						BerTag passedTag = berTag;

						if (berTag == null) {
							berTag = new BerTag();
							codeLength += berTag.decode(is);
						}

						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
							masterChannel = new BerNull();
							codeLength += masterChannel.decode(is, false);
							return codeLength;
						}

						if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
							virtualChannel = new BerInteger();
							codeLength += virtualChannel.decode(is, false);
							return codeLength;
						}

						if (passedTag != null) {
							return 0;
						}

						throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
					}

					public void encodeAndSave(int encodingSizeGuess) throws IOException {
						ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
						encode(reverseOS);
						code = reverseOS.getArray();
					}

					public String toString() {
						StringBuilder sb = new StringBuilder();
						appendAsString(sb, 0);
						return sb.toString();
					}

					public void appendAsString(StringBuilder sb, int indentLevel) {

						if (masterChannel != null) {
							sb.append("masterChannel: ").append(masterChannel);
							return;
						}

						if (virtualChannel != null) {
							sb.append("virtualChannel: ").append(virtualChannel);
							return;
						}

						sb.append("<none>");
					}

				}

				public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

				public byte[] code = null;
				private BerInteger tfvn = null;
				private BerInteger scid = null;
				private Vcid vcid = null;
				
				public Tfvn12() {
				}

				public Tfvn12(byte[] code) {
					this.code = code;
				}

				public void setTfvn(BerInteger tfvn) {
					this.tfvn = tfvn;
				}

				public BerInteger getTfvn() {
					return tfvn;
				}

				public void setScid(BerInteger scid) {
					this.scid = scid;
				}

				public BerInteger getScid() {
					return scid;
				}

				public void setVcid(Vcid vcid) {
					this.vcid = vcid;
				}

				public Vcid getVcid() {
					return vcid;
				}

				public int encode(OutputStream reverseOS) throws IOException {
					return encode(reverseOS, true);
				}

				public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

					if (code != null) {
						for (int i = code.length - 1; i >= 0; i--) {
							reverseOS.write(code[i]);
						}
						if (withTag) {
							return tag.encode(reverseOS) + code.length;
						}
						return code.length;
					}

					int codeLength = 0;
					codeLength += vcid.encode(reverseOS);
					
					codeLength += scid.encode(reverseOS, true);
					
					codeLength += tfvn.encode(reverseOS, true);
					
					codeLength += BerLength.encodeLength(reverseOS, codeLength);

					if (withTag) {
						codeLength += tag.encode(reverseOS);
					}

					return codeLength;

				}

				public int decode(InputStream is) throws IOException {
					return decode(is, true);
				}

				public int decode(InputStream is, boolean withTag) throws IOException {
					int codeLength = 0;
					int subCodeLength = 0;
					BerTag berTag = new BerTag();

					if (withTag) {
						codeLength += tag.decodeAndCheck(is);
					}

					BerLength length = new BerLength();
					codeLength += length.decode(is);

					int totalLength = length.val;
					codeLength += totalLength;

					subCodeLength += berTag.decode(is);
					if (berTag.equals(BerInteger.tag)) {
						tfvn = new BerInteger();
						subCodeLength += tfvn.decode(is, false);
						subCodeLength += berTag.decode(is);
					}
					else {
						throw new IOException("Tag does not match the mandatory sequence element tag.");
					}
					
					if (berTag.equals(BerInteger.tag)) {
						scid = new BerInteger();
						subCodeLength += scid.decode(is, false);
						subCodeLength += berTag.decode(is);
					}
					else {
						throw new IOException("Tag does not match the mandatory sequence element tag.");
					}
					
					vcid = new Vcid();
					subCodeLength += vcid.decode(is, berTag);
					if (subCodeLength == totalLength) {
						return codeLength;
					}
					throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

					
				}

				public void encodeAndSave(int encodingSizeGuess) throws IOException {
					ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
					encode(reverseOS, false);
					code = reverseOS.getArray();
				}

				public String toString() {
					StringBuilder sb = new StringBuilder();
					appendAsString(sb, 0);
					return sb.toString();
				}

				public void appendAsString(StringBuilder sb, int indentLevel) {

					sb.append("{");
					sb.append("\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (tfvn != null) {
						sb.append("tfvn: ").append(tfvn);
					}
					else {
						sb.append("tfvn: <empty-required-field>");
					}
					
					sb.append(",\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (scid != null) {
						sb.append("scid: ").append(scid);
					}
					else {
						sb.append("scid: <empty-required-field>");
					}
					
					sb.append(",\n");
					for (int i = 0; i < indentLevel + 1; i++) {
						sb.append("\t");
					}
					if (vcid != null) {
						sb.append("vcid: ");
						vcid.appendAsString(sb, indentLevel + 1);
					}
					else {
						sb.append("vcid: <empty-required-field>");
					}
					
					sb.append("\n");
					for (int i = 0; i < indentLevel; i++) {
						sb.append("\t");
					}
					sb.append("}");
				}

			}

			public static class Element4 implements BerType, Serializable {

				private static final long serialVersionUID = 1L;

				public byte[] code = null;
				public static class Tfvn0 implements BerType, Serializable {

					private static final long serialVersionUID = 1L;

					public static class Vcid implements BerType, Serializable {

						private static final long serialVersionUID = 1L;

						public byte[] code = null;
						private BerNull masterChannel = null;
						private BerInteger virtualChannel = null;
						
						public Vcid() {
						}

						public Vcid(byte[] code) {
							this.code = code;
						}

						public void setMasterChannel(BerNull masterChannel) {
							this.masterChannel = masterChannel;
						}

						public BerNull getMasterChannel() {
							return masterChannel;
						}

						public void setVirtualChannel(BerInteger virtualChannel) {
							this.virtualChannel = virtualChannel;
						}

						public BerInteger getVirtualChannel() {
							return virtualChannel;
						}

						public int encode(OutputStream reverseOS) throws IOException {

							if (code != null) {
								for (int i = code.length - 1; i >= 0; i--) {
									reverseOS.write(code[i]);
								}
								return code.length;
							}

							int codeLength = 0;
							if (virtualChannel != null) {
								codeLength += virtualChannel.encode(reverseOS, false);
								// write tag: CONTEXT_CLASS, PRIMITIVE, 1
								reverseOS.write(0x81);
								codeLength += 1;
								return codeLength;
							}
							
							if (masterChannel != null) {
								codeLength += masterChannel.encode(reverseOS, false);
								// write tag: CONTEXT_CLASS, PRIMITIVE, 0
								reverseOS.write(0x80);
								codeLength += 1;
								return codeLength;
							}
							
							throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
						}

						public int decode(InputStream is) throws IOException {
							return decode(is, null);
						}

						public int decode(InputStream is, BerTag berTag) throws IOException {

							int codeLength = 0;
							BerTag passedTag = berTag;

							if (berTag == null) {
								berTag = new BerTag();
								codeLength += berTag.decode(is);
							}

							if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
								masterChannel = new BerNull();
								codeLength += masterChannel.decode(is, false);
								return codeLength;
							}

							if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
								virtualChannel = new BerInteger();
								codeLength += virtualChannel.decode(is, false);
								return codeLength;
							}

							if (passedTag != null) {
								return 0;
							}

							throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
						}

						public void encodeAndSave(int encodingSizeGuess) throws IOException {
							ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
							encode(reverseOS);
							code = reverseOS.getArray();
						}

						public String toString() {
							StringBuilder sb = new StringBuilder();
							appendAsString(sb, 0);
							return sb.toString();
						}

						public void appendAsString(StringBuilder sb, int indentLevel) {

							if (masterChannel != null) {
								sb.append("masterChannel: ").append(masterChannel);
								return;
							}

							if (virtualChannel != null) {
								sb.append("virtualChannel: ").append(virtualChannel);
								return;
							}

							sb.append("<none>");
						}

					}

					public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

					public byte[] code = null;
					private BerInteger tfvn = null;
					private BerInteger scid = null;
					private Vcid vcid = null;
					
					public Tfvn0() {
					}

					public Tfvn0(byte[] code) {
						this.code = code;
					}

					public void setTfvn(BerInteger tfvn) {
						this.tfvn = tfvn;
					}

					public BerInteger getTfvn() {
						return tfvn;
					}

					public void setScid(BerInteger scid) {
						this.scid = scid;
					}

					public BerInteger getScid() {
						return scid;
					}

					public void setVcid(Vcid vcid) {
						this.vcid = vcid;
					}

					public Vcid getVcid() {
						return vcid;
					}

					public int encode(OutputStream reverseOS) throws IOException {
						return encode(reverseOS, true);
					}

					public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

						if (code != null) {
							for (int i = code.length - 1; i >= 0; i--) {
								reverseOS.write(code[i]);
							}
							if (withTag) {
								return tag.encode(reverseOS) + code.length;
							}
							return code.length;
						}

						int codeLength = 0;
						codeLength += vcid.encode(reverseOS);
						
						codeLength += scid.encode(reverseOS, true);
						
						codeLength += tfvn.encode(reverseOS, true);
						
						codeLength += BerLength.encodeLength(reverseOS, codeLength);

						if (withTag) {
							codeLength += tag.encode(reverseOS);
						}

						return codeLength;

					}

					public int decode(InputStream is) throws IOException {
						return decode(is, true);
					}

					public int decode(InputStream is, boolean withTag) throws IOException {
						int codeLength = 0;
						int subCodeLength = 0;
						BerTag berTag = new BerTag();

						if (withTag) {
							codeLength += tag.decodeAndCheck(is);
						}

						BerLength length = new BerLength();
						codeLength += length.decode(is);

						int totalLength = length.val;
						codeLength += totalLength;

						subCodeLength += berTag.decode(is);
						if (berTag.equals(BerInteger.tag)) {
							tfvn = new BerInteger();
							subCodeLength += tfvn.decode(is, false);
							subCodeLength += berTag.decode(is);
						}
						else {
							throw new IOException("Tag does not match the mandatory sequence element tag.");
						}
						
						if (berTag.equals(BerInteger.tag)) {
							scid = new BerInteger();
							subCodeLength += scid.decode(is, false);
							subCodeLength += berTag.decode(is);
						}
						else {
							throw new IOException("Tag does not match the mandatory sequence element tag.");
						}
						
						vcid = new Vcid();
						subCodeLength += vcid.decode(is, berTag);
						if (subCodeLength == totalLength) {
							return codeLength;
						}
						throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

						
					}

					public void encodeAndSave(int encodingSizeGuess) throws IOException {
						ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
						encode(reverseOS, false);
						code = reverseOS.getArray();
					}

					public String toString() {
						StringBuilder sb = new StringBuilder();
						appendAsString(sb, 0);
						return sb.toString();
					}

					public void appendAsString(StringBuilder sb, int indentLevel) {

						sb.append("{");
						sb.append("\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (tfvn != null) {
							sb.append("tfvn: ").append(tfvn);
						}
						else {
							sb.append("tfvn: <empty-required-field>");
						}
						
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (scid != null) {
							sb.append("scid: ").append(scid);
						}
						else {
							sb.append("scid: <empty-required-field>");
						}
						
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (vcid != null) {
							sb.append("vcid: ");
							vcid.appendAsString(sb, indentLevel + 1);
						}
						else {
							sb.append("vcid: <empty-required-field>");
						}
						
						sb.append("\n");
						for (int i = 0; i < indentLevel; i++) {
							sb.append("\t");
						}
						sb.append("}");
					}

				}

				public static class Tfvn1 implements BerType, Serializable {

					private static final long serialVersionUID = 1L;

					public static class Vcid implements BerType, Serializable {

						private static final long serialVersionUID = 1L;

						public byte[] code = null;
						private BerNull masterChannel = null;
						private BerInteger virtualChannel = null;
						
						public Vcid() {
						}

						public Vcid(byte[] code) {
							this.code = code;
						}

						public void setMasterChannel(BerNull masterChannel) {
							this.masterChannel = masterChannel;
						}

						public BerNull getMasterChannel() {
							return masterChannel;
						}

						public void setVirtualChannel(BerInteger virtualChannel) {
							this.virtualChannel = virtualChannel;
						}

						public BerInteger getVirtualChannel() {
							return virtualChannel;
						}

						public int encode(OutputStream reverseOS) throws IOException {

							if (code != null) {
								for (int i = code.length - 1; i >= 0; i--) {
									reverseOS.write(code[i]);
								}
								return code.length;
							}

							int codeLength = 0;
							if (virtualChannel != null) {
								codeLength += virtualChannel.encode(reverseOS, false);
								// write tag: CONTEXT_CLASS, PRIMITIVE, 1
								reverseOS.write(0x81);
								codeLength += 1;
								return codeLength;
							}
							
							if (masterChannel != null) {
								codeLength += masterChannel.encode(reverseOS, false);
								// write tag: CONTEXT_CLASS, PRIMITIVE, 0
								reverseOS.write(0x80);
								codeLength += 1;
								return codeLength;
							}
							
							throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
						}

						public int decode(InputStream is) throws IOException {
							return decode(is, null);
						}

						public int decode(InputStream is, BerTag berTag) throws IOException {

							int codeLength = 0;
							BerTag passedTag = berTag;

							if (berTag == null) {
								berTag = new BerTag();
								codeLength += berTag.decode(is);
							}

							if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
								masterChannel = new BerNull();
								codeLength += masterChannel.decode(is, false);
								return codeLength;
							}

							if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
								virtualChannel = new BerInteger();
								codeLength += virtualChannel.decode(is, false);
								return codeLength;
							}

							if (passedTag != null) {
								return 0;
							}

							throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
						}

						public void encodeAndSave(int encodingSizeGuess) throws IOException {
							ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
							encode(reverseOS);
							code = reverseOS.getArray();
						}

						public String toString() {
							StringBuilder sb = new StringBuilder();
							appendAsString(sb, 0);
							return sb.toString();
						}

						public void appendAsString(StringBuilder sb, int indentLevel) {

							if (masterChannel != null) {
								sb.append("masterChannel: ").append(masterChannel);
								return;
							}

							if (virtualChannel != null) {
								sb.append("virtualChannel: ").append(virtualChannel);
								return;
							}

							sb.append("<none>");
						}

					}

					public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

					public byte[] code = null;
					private BerInteger tfvn = null;
					private BerInteger scid = null;
					private Vcid vcid = null;
					
					public Tfvn1() {
					}

					public Tfvn1(byte[] code) {
						this.code = code;
					}

					public void setTfvn(BerInteger tfvn) {
						this.tfvn = tfvn;
					}

					public BerInteger getTfvn() {
						return tfvn;
					}

					public void setScid(BerInteger scid) {
						this.scid = scid;
					}

					public BerInteger getScid() {
						return scid;
					}

					public void setVcid(Vcid vcid) {
						this.vcid = vcid;
					}

					public Vcid getVcid() {
						return vcid;
					}

					public int encode(OutputStream reverseOS) throws IOException {
						return encode(reverseOS, true);
					}

					public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

						if (code != null) {
							for (int i = code.length - 1; i >= 0; i--) {
								reverseOS.write(code[i]);
							}
							if (withTag) {
								return tag.encode(reverseOS) + code.length;
							}
							return code.length;
						}

						int codeLength = 0;
						codeLength += vcid.encode(reverseOS);
						
						codeLength += scid.encode(reverseOS, true);
						
						codeLength += tfvn.encode(reverseOS, true);
						
						codeLength += BerLength.encodeLength(reverseOS, codeLength);

						if (withTag) {
							codeLength += tag.encode(reverseOS);
						}

						return codeLength;

					}

					public int decode(InputStream is) throws IOException {
						return decode(is, true);
					}

					public int decode(InputStream is, boolean withTag) throws IOException {
						int codeLength = 0;
						int subCodeLength = 0;
						BerTag berTag = new BerTag();

						if (withTag) {
							codeLength += tag.decodeAndCheck(is);
						}

						BerLength length = new BerLength();
						codeLength += length.decode(is);

						int totalLength = length.val;
						codeLength += totalLength;

						subCodeLength += berTag.decode(is);
						if (berTag.equals(BerInteger.tag)) {
							tfvn = new BerInteger();
							subCodeLength += tfvn.decode(is, false);
							subCodeLength += berTag.decode(is);
						}
						else {
							throw new IOException("Tag does not match the mandatory sequence element tag.");
						}
						
						if (berTag.equals(BerInteger.tag)) {
							scid = new BerInteger();
							subCodeLength += scid.decode(is, false);
							subCodeLength += berTag.decode(is);
						}
						else {
							throw new IOException("Tag does not match the mandatory sequence element tag.");
						}
						
						vcid = new Vcid();
						subCodeLength += vcid.decode(is, berTag);
						if (subCodeLength == totalLength) {
							return codeLength;
						}
						throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

						
					}

					public void encodeAndSave(int encodingSizeGuess) throws IOException {
						ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
						encode(reverseOS, false);
						code = reverseOS.getArray();
					}

					public String toString() {
						StringBuilder sb = new StringBuilder();
						appendAsString(sb, 0);
						return sb.toString();
					}

					public void appendAsString(StringBuilder sb, int indentLevel) {

						sb.append("{");
						sb.append("\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (tfvn != null) {
							sb.append("tfvn: ").append(tfvn);
						}
						else {
							sb.append("tfvn: <empty-required-field>");
						}
						
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (scid != null) {
							sb.append("scid: ").append(scid);
						}
						else {
							sb.append("scid: <empty-required-field>");
						}
						
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (vcid != null) {
							sb.append("vcid: ");
							vcid.appendAsString(sb, indentLevel + 1);
						}
						else {
							sb.append("vcid: <empty-required-field>");
						}
						
						sb.append("\n");
						for (int i = 0; i < indentLevel; i++) {
							sb.append("\t");
						}
						sb.append("}");
					}

				}

				public static class Tfvn12 implements BerType, Serializable {

					private static final long serialVersionUID = 1L;

					public static class Vcid implements BerType, Serializable {

						private static final long serialVersionUID = 1L;

						public byte[] code = null;
						private BerNull masterChannel = null;
						private BerInteger virtualChannel = null;
						
						public Vcid() {
						}

						public Vcid(byte[] code) {
							this.code = code;
						}

						public void setMasterChannel(BerNull masterChannel) {
							this.masterChannel = masterChannel;
						}

						public BerNull getMasterChannel() {
							return masterChannel;
						}

						public void setVirtualChannel(BerInteger virtualChannel) {
							this.virtualChannel = virtualChannel;
						}

						public BerInteger getVirtualChannel() {
							return virtualChannel;
						}

						public int encode(OutputStream reverseOS) throws IOException {

							if (code != null) {
								for (int i = code.length - 1; i >= 0; i--) {
									reverseOS.write(code[i]);
								}
								return code.length;
							}

							int codeLength = 0;
							if (virtualChannel != null) {
								codeLength += virtualChannel.encode(reverseOS, false);
								// write tag: CONTEXT_CLASS, PRIMITIVE, 1
								reverseOS.write(0x81);
								codeLength += 1;
								return codeLength;
							}
							
							if (masterChannel != null) {
								codeLength += masterChannel.encode(reverseOS, false);
								// write tag: CONTEXT_CLASS, PRIMITIVE, 0
								reverseOS.write(0x80);
								codeLength += 1;
								return codeLength;
							}
							
							throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
						}

						public int decode(InputStream is) throws IOException {
							return decode(is, null);
						}

						public int decode(InputStream is, BerTag berTag) throws IOException {

							int codeLength = 0;
							BerTag passedTag = berTag;

							if (berTag == null) {
								berTag = new BerTag();
								codeLength += berTag.decode(is);
							}

							if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
								masterChannel = new BerNull();
								codeLength += masterChannel.decode(is, false);
								return codeLength;
							}

							if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 1)) {
								virtualChannel = new BerInteger();
								codeLength += virtualChannel.decode(is, false);
								return codeLength;
							}

							if (passedTag != null) {
								return 0;
							}

							throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
						}

						public void encodeAndSave(int encodingSizeGuess) throws IOException {
							ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
							encode(reverseOS);
							code = reverseOS.getArray();
						}

						public String toString() {
							StringBuilder sb = new StringBuilder();
							appendAsString(sb, 0);
							return sb.toString();
						}

						public void appendAsString(StringBuilder sb, int indentLevel) {

							if (masterChannel != null) {
								sb.append("masterChannel: ").append(masterChannel);
								return;
							}

							if (virtualChannel != null) {
								sb.append("virtualChannel: ").append(virtualChannel);
								return;
							}

							sb.append("<none>");
						}

					}

					public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

					public byte[] code = null;
					private BerInteger tfvn = null;
					private BerInteger scid = null;
					private Vcid vcid = null;
					
					public Tfvn12() {
					}

					public Tfvn12(byte[] code) {
						this.code = code;
					}

					public void setTfvn(BerInteger tfvn) {
						this.tfvn = tfvn;
					}

					public BerInteger getTfvn() {
						return tfvn;
					}

					public void setScid(BerInteger scid) {
						this.scid = scid;
					}

					public BerInteger getScid() {
						return scid;
					}

					public void setVcid(Vcid vcid) {
						this.vcid = vcid;
					}

					public Vcid getVcid() {
						return vcid;
					}

					public int encode(OutputStream reverseOS) throws IOException {
						return encode(reverseOS, true);
					}

					public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

						if (code != null) {
							for (int i = code.length - 1; i >= 0; i--) {
								reverseOS.write(code[i]);
							}
							if (withTag) {
								return tag.encode(reverseOS) + code.length;
							}
							return code.length;
						}

						int codeLength = 0;
						codeLength += vcid.encode(reverseOS);
						
						codeLength += scid.encode(reverseOS, true);
						
						codeLength += tfvn.encode(reverseOS, true);
						
						codeLength += BerLength.encodeLength(reverseOS, codeLength);

						if (withTag) {
							codeLength += tag.encode(reverseOS);
						}

						return codeLength;

					}

					public int decode(InputStream is) throws IOException {
						return decode(is, true);
					}

					public int decode(InputStream is, boolean withTag) throws IOException {
						int codeLength = 0;
						int subCodeLength = 0;
						BerTag berTag = new BerTag();

						if (withTag) {
							codeLength += tag.decodeAndCheck(is);
						}

						BerLength length = new BerLength();
						codeLength += length.decode(is);

						int totalLength = length.val;
						codeLength += totalLength;

						subCodeLength += berTag.decode(is);
						if (berTag.equals(BerInteger.tag)) {
							tfvn = new BerInteger();
							subCodeLength += tfvn.decode(is, false);
							subCodeLength += berTag.decode(is);
						}
						else {
							throw new IOException("Tag does not match the mandatory sequence element tag.");
						}
						
						if (berTag.equals(BerInteger.tag)) {
							scid = new BerInteger();
							subCodeLength += scid.decode(is, false);
							subCodeLength += berTag.decode(is);
						}
						else {
							throw new IOException("Tag does not match the mandatory sequence element tag.");
						}
						
						vcid = new Vcid();
						subCodeLength += vcid.decode(is, berTag);
						if (subCodeLength == totalLength) {
							return codeLength;
						}
						throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

						
					}

					public void encodeAndSave(int encodingSizeGuess) throws IOException {
						ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
						encode(reverseOS, false);
						code = reverseOS.getArray();
					}

					public String toString() {
						StringBuilder sb = new StringBuilder();
						appendAsString(sb, 0);
						return sb.toString();
					}

					public void appendAsString(StringBuilder sb, int indentLevel) {

						sb.append("{");
						sb.append("\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (tfvn != null) {
							sb.append("tfvn: ").append(tfvn);
						}
						else {
							sb.append("tfvn: <empty-required-field>");
						}
						
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (scid != null) {
							sb.append("scid: ").append(scid);
						}
						else {
							sb.append("scid: <empty-required-field>");
						}
						
						sb.append(",\n");
						for (int i = 0; i < indentLevel + 1; i++) {
							sb.append("\t");
						}
						if (vcid != null) {
							sb.append("vcid: ");
							vcid.appendAsString(sb, indentLevel + 1);
						}
						else {
							sb.append("vcid: <empty-required-field>");
						}
						
						sb.append("\n");
						for (int i = 0; i < indentLevel; i++) {
							sb.append("\t");
						}
						sb.append("}");
					}

				}

				private Tfvn0 tfvn0 = null;
				private Tfvn1 tfvn1 = null;
				private Tfvn12 tfvn12 = null;
				
				public Element4() {
				}

				public Element4(byte[] code) {
					this.code = code;
				}

				public void setTfvn0(Tfvn0 tfvn0) {
					this.tfvn0 = tfvn0;
				}

				public Tfvn0 getTfvn0() {
					return tfvn0;
				}

				public void setTfvn1(Tfvn1 tfvn1) {
					this.tfvn1 = tfvn1;
				}

				public Tfvn1 getTfvn1() {
					return tfvn1;
				}

				public void setTfvn12(Tfvn12 tfvn12) {
					this.tfvn12 = tfvn12;
				}

				public Tfvn12 getTfvn12() {
					return tfvn12;
				}

				public int encode(OutputStream reverseOS) throws IOException {

					if (code != null) {
						for (int i = code.length - 1; i >= 0; i--) {
							reverseOS.write(code[i]);
						}
						return code.length;
					}

					int codeLength = 0;
					if (tfvn12 != null) {
						codeLength += tfvn12.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, CONSTRUCTED, 2
						reverseOS.write(0xA2);
						codeLength += 1;
						return codeLength;
					}
					
					if (tfvn1 != null) {
						codeLength += tfvn1.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
						reverseOS.write(0xA1);
						codeLength += 1;
						return codeLength;
					}
					
					if (tfvn0 != null) {
						codeLength += tfvn0.encode(reverseOS, false);
						// write tag: CONTEXT_CLASS, CONSTRUCTED, 0
						reverseOS.write(0xA0);
						codeLength += 1;
						return codeLength;
					}
					
					throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
				}

				public int decode(InputStream is) throws IOException {
					return decode(is, null);
				}

				public int decode(InputStream is, BerTag berTag) throws IOException {

					int codeLength = 0;
					BerTag passedTag = berTag;

					if (berTag == null) {
						berTag = new BerTag();
						codeLength += berTag.decode(is);
					}

					if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 0)) {
						tfvn0 = new Tfvn0();
						codeLength += tfvn0.decode(is, false);
						return codeLength;
					}

					if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
						tfvn1 = new Tfvn1();
						codeLength += tfvn1.decode(is, false);
						return codeLength;
					}

					if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 2)) {
						tfvn12 = new Tfvn12();
						codeLength += tfvn12.decode(is, false);
						return codeLength;
					}

					if (passedTag != null) {
						return 0;
					}

					throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
				}

				public void encodeAndSave(int encodingSizeGuess) throws IOException {
					ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
					encode(reverseOS);
					code = reverseOS.getArray();
				}

				public String toString() {
					StringBuilder sb = new StringBuilder();
					appendAsString(sb, 0);
					return sb.toString();
				}

				public void appendAsString(StringBuilder sb, int indentLevel) {

					if (tfvn0 != null) {
						sb.append("tfvn0: ");
						tfvn0.appendAsString(sb, indentLevel + 1);
						return;
					}

					if (tfvn1 != null) {
						sb.append("tfvn1: ");
						tfvn1.appendAsString(sb, indentLevel + 1);
						return;
					}

					if (tfvn12 != null) {
						sb.append("tfvn12: ");
						tfvn12.appendAsString(sb, indentLevel + 1);
						return;
					}

					sb.append("<none>");
				}

			}

			private Tfvn0 tfvn0 = null;
			private Tfvn1 tfvn1 = null;
			private Tfvn12 tfvn12 = null;
			private Element4 element4 = null;
			
			public ClcwSource() {
			}

			public ClcwSource(byte[] code) {
				this.code = code;
			}

			public void setTfvn0(Tfvn0 tfvn0) {
				this.tfvn0 = tfvn0;
			}

			public Tfvn0 getTfvn0() {
				return tfvn0;
			}

			public void setTfvn1(Tfvn1 tfvn1) {
				this.tfvn1 = tfvn1;
			}

			public Tfvn1 getTfvn1() {
				return tfvn1;
			}

			public void setTfvn12(Tfvn12 tfvn12) {
				this.tfvn12 = tfvn12;
			}

			public Tfvn12 getTfvn12() {
				return tfvn12;
			}

			public void setElement4(Element4 element4) {
				this.element4 = element4;
			}

			public Element4 getElement4() {
				return element4;
			}

			public int encode(OutputStream reverseOS) throws IOException {

				if (code != null) {
					for (int i = code.length - 1; i >= 0; i--) {
						reverseOS.write(code[i]);
					}
					return code.length;
				}

				int codeLength = 0;
				if (element4 != null) {
					codeLength += element4.encode(reverseOS);
					return codeLength;
				}
				
				if (tfvn12 != null) {
					codeLength += tfvn12.encode(reverseOS, false);
					// write tag: CONTEXT_CLASS, CONSTRUCTED, 2
					reverseOS.write(0xA2);
					codeLength += 1;
					return codeLength;
				}
				
				if (tfvn1 != null) {
					codeLength += tfvn1.encode(reverseOS, false);
					// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
					reverseOS.write(0xA1);
					codeLength += 1;
					return codeLength;
				}
				
				if (tfvn0 != null) {
					codeLength += tfvn0.encode(reverseOS, false);
					// write tag: CONTEXT_CLASS, CONSTRUCTED, 0
					reverseOS.write(0xA0);
					codeLength += 1;
					return codeLength;
				}
				
				throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
			}

			public int decode(InputStream is) throws IOException {
				return decode(is, null);
			}

			public int decode(InputStream is, BerTag berTag) throws IOException {

				int codeLength = 0;
				BerTag passedTag = berTag;

				if (berTag == null) {
					berTag = new BerTag();
					codeLength += berTag.decode(is);
				}

				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 0)) {
					tfvn0 = new Tfvn0();
					codeLength += tfvn0.decode(is, false);
					return codeLength;
				}

				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
					tfvn1 = new Tfvn1();
					codeLength += tfvn1.decode(is, false);
					return codeLength;
				}

				if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 2)) {
					tfvn12 = new Tfvn12();
					codeLength += tfvn12.decode(is, false);
					return codeLength;
				}

				element4 = new Element4();
				int choiceDecodeLength = element4.decode(is, berTag);
				if (choiceDecodeLength != 0) {
					return codeLength + choiceDecodeLength;
				}
				else {
					element4 = null;
				}

				if (passedTag != null) {
					return 0;
				}

				throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
			}

			public void encodeAndSave(int encodingSizeGuess) throws IOException {
				ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
				encode(reverseOS);
				code = reverseOS.getArray();
			}

			public String toString() {
				StringBuilder sb = new StringBuilder();
				appendAsString(sb, 0);
				return sb.toString();
			}

			public void appendAsString(StringBuilder sb, int indentLevel) {

				if (tfvn0 != null) {
					sb.append("tfvn0: ");
					tfvn0.appendAsString(sb, indentLevel + 1);
					return;
				}

				if (tfvn1 != null) {
					sb.append("tfvn1: ");
					tfvn1.appendAsString(sb, indentLevel + 1);
					return;
				}

				if (tfvn12 != null) {
					sb.append("tfvn12: ");
					tfvn12.appendAsString(sb, indentLevel + 1);
					return;
				}

				if (element4 != null) {
					sb.append("element4: ");
					element4.appendAsString(sb, indentLevel + 1);
					return;
				}

				sb.append("<none>");
			}

		}

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private BerEnum linkCondition = null;
		private ClcwSource clcwSource = null;
		
		public Evaluation() {
		}

		public Evaluation(byte[] code) {
			this.code = code;
		}

		public void setLinkCondition(BerEnum linkCondition) {
			this.linkCondition = linkCondition;
		}

		public BerEnum getLinkCondition() {
			return linkCondition;
		}

		public void setClcwSource(ClcwSource clcwSource) {
			this.clcwSource = clcwSource;
		}

		public ClcwSource getClcwSource() {
			return clcwSource;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += clcwSource.encode(reverseOS);
			
			codeLength += linkCondition.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(BerEnum.tag)) {
				linkCondition = new BerEnum();
				subCodeLength += linkCondition.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			clcwSource = new ClcwSource();
			subCodeLength += clcwSource.decode(is, berTag);
			if (subCodeLength == totalLength) {
				return codeLength;
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (linkCondition != null) {
				sb.append("linkCondition: ").append(linkCondition);
			}
			else {
				sb.append("linkCondition: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (clcwSource != null) {
				sb.append("clcwSource: ");
				clcwSource.appendAsString(sb, indentLevel + 1);
			}
			else {
				sb.append("clcwSource: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	private BerNull noEvaluation = null;
	private Evaluation evaluation = null;
	
	public FwdTcPlopSyncClcwEvaluation() {
	}

	public FwdTcPlopSyncClcwEvaluation(byte[] code) {
		this.code = code;
	}

	public void setNoEvaluation(BerNull noEvaluation) {
		this.noEvaluation = noEvaluation;
	}

	public BerNull getNoEvaluation() {
		return noEvaluation;
	}

	public void setEvaluation(Evaluation evaluation) {
		this.evaluation = evaluation;
	}

	public Evaluation getEvaluation() {
		return evaluation;
	}

	public int encode(OutputStream reverseOS) throws IOException {

		if (code != null) {
			for (int i = code.length - 1; i >= 0; i--) {
				reverseOS.write(code[i]);
			}
			return code.length;
		}

		int codeLength = 0;
		if (evaluation != null) {
			codeLength += evaluation.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
			reverseOS.write(0xA1);
			codeLength += 1;
			return codeLength;
		}
		
		if (noEvaluation != null) {
			codeLength += noEvaluation.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, PRIMITIVE, 0
			reverseOS.write(0x80);
			codeLength += 1;
			return codeLength;
		}
		
		throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
	}

	public int decode(InputStream is) throws IOException {
		return decode(is, null);
	}

	public int decode(InputStream is, BerTag berTag) throws IOException {

		int codeLength = 0;
		BerTag passedTag = berTag;

		if (berTag == null) {
			berTag = new BerTag();
			codeLength += berTag.decode(is);
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.PRIMITIVE, 0)) {
			noEvaluation = new BerNull();
			codeLength += noEvaluation.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
			evaluation = new Evaluation();
			codeLength += evaluation.decode(is, false);
			return codeLength;
		}

		if (passedTag != null) {
			return 0;
		}

		throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
	}

	public void encodeAndSave(int encodingSizeGuess) throws IOException {
		ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
		encode(reverseOS);
		code = reverseOS.getArray();
	}

	public String toString() {
		StringBuilder sb = new StringBuilder();
		appendAsString(sb, 0);
		return sb.toString();
	}

	public void appendAsString(StringBuilder sb, int indentLevel) {

		if (noEvaluation != null) {
			sb.append("noEvaluation: ").append(noEvaluation);
			return;
		}

		if (evaluation != null) {
			sb.append("evaluation: ");
			evaluation.appendAsString(sb, indentLevel + 1);
			return;
		}

		sb.append("<none>");
	}

}

